## 权值线段树
> 出于权值树的特殊性，还是单开了
```cpp
int n;
int t[N<<2];

void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 单点修改
void put(int k,int v,int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] += v;
		return ;
	}
	int mid = (be+ed) >> 1;
	if(k <= mid)	put(k,v,be,mid,p<<1);
	else	put(k,v,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询[l,r]内共有多少个数
int query_cnt(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	int mid = (be+ed) >> 1,cnt = 0;
	if(l <= mid)	cnt += query_cnt(l,r,be,mid,p<<1);
	if(mid+1 <= r)	cnt += query_cnt(l,r,mid+1,ed,p<<1|1);
	return cnt;
}
// 查询第 k 个数的值
int query_k(int k,int be=1,int ed=n,int p=1)// 实际是个线段树二分
{
	if(be == ed)	return be;
	int mid = (be+ed) >> 1, lsum = t[p<<1];
	if(lsum >= k)	return query_k(k,be,mid,p<<1);
	else return query_k(k-lsum,mid+1,ed,p<<1|1);
}
```

### 题目
#### 负数信息维护
权值树可以维护负数信息，只要保证查询时节点不变即可。用法和朴素权值树一样。
> 或者对坐标轴偏移

[22ICPC沈阳I](https://codeforces.com/gym/104160/problem/I)
但是这题对正负权需要分别处理，所以开了两棵树而没有放在一起。

题意：$n$ 种物品各两个，价格为 $a_i,b_i \le 10^5$，$a$ 被售卖后才会上架 $b$。
两个人需要 $n$ 个物品各一个，轮流购买。$A$ 先买一个，然后轮流一人两个。
两个人最小化自己活动 $n$ 种物品的开销。
$m$ 次询问，回答可持久化的修改某种物品的价值后 $A$ 的最小开销。

只需要考虑 $a_i - b_i$，两者博弈是否获得。
- 对于 $a_i - b_i \le 0$，$A$ 拿大小顺序 $0,1$ 的。
- 对于 $a_i - b_i > 0$，可以拿之前对方拿过的，来减少损失，实际顺序可以看代码，和奇偶性有关。

```cpp 
struct node
{
    int cnt;
    array<int,4> s;
}t[2][N<<2];

int n,m;
int a[N], b[N], sum;

void push_up(int op,int p)
{
    auto t1 = t[op][p<<1], t2 = t[op][p<<1|1];
    if(op)  t1 = t[op][p<<1|1], t2 = t[op][p<<1];
    t[op][p] = t2;    t[op][p].cnt += t1.cnt;
    for(int i=0;i<4;++i)    t[op][p].s[(i+t2.cnt)%4] += t1.s[i];
}

void put(int op,int k,int z,int be=0,int ed=N,int p=1)
{
    if(be == ed)
    {
        if(z)
        {
            t[op][p].cnt ++;
            t[op][p].s[t[op][p].cnt%4] += k;
        }
        else
        {
            t[op][p].s[t[op][p].cnt%4] -= k;
            t[op][p].cnt --;
        }
        return;
    }
    int mid = (be + ed) >> 1;
    if(k <= mid)    put(op,k,z,be,mid,p<<1);
    else            put(op,k,z,mid+1,ed,p<<1|1);
    push_up(op,p);
}

void ans(void)
{
    int res = t[0][1].s[0] + t[0][1].s[1];
    res -= (t[0][1].cnt&1 ? t[1][1].s[0]+t[1][1].s[2] : t[1][1].s[1]+t[1][1].s[3]);
    cout << sum-res << '\n';
}

void func(void)
{
    cin >> n >> m;
    for(int i=1;i<=n;++i)   cin >> a[i] >> b[i];
    int res = 0;
    for(int i=1;i<=n;++i)
    {
        sum += b[i];
        int z = a[i]-b[i];
        put(z>0,abs(z),1);
    }
    ans();
    while(m --)
    {
        int t,x,y;  cin >> t >> x >> y;
        int z = a[t]-b[t];
        sum -= b[t];
        put(z>0,abs(z),0);
        a[t] = x, b[t] = y, z = x-y, sum += y;
        put(z>0,abs(z),1);
        ans();
    }
}
```
[TOC]
### 各种区间信息
#### 区间和
$\sum xa_i+b = x\sum a_i + len\times b$
```cpp
struct node
{
	int sum,mul,add;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
#### 区间平方和
$\sum (xa_i+y) = x^2 \sum a_i^2 + 2xy \sum a_i + len\times y^2$

需要维护区间和
```cpp
struct node
{
    // 区间和, 平方和, 加lz，乘lz
	int sum,sq,add,mul;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sq = t[p].sq*mul*mul + t[p].sum*add*2 + (ed-be+1)*add*add;
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
	t[p].sq = t[p<<1].sq + t[p<<1|1].sq;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,0,0,1};
	if(be == ed)
	{
		t[p] = {a[be],a[be]*a[be],0,1};
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sq;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

// 区间乘
put(l,r,0,x);
// 区间加
put(l,r,x,1);
```

#### 区间乘积和
求区间 $l$ 到 $r$ 之间两两之间数字的乘积和(例如：$2,3,4,5$两两之间乘积和为 $2\times3+2\times4+2\times5+3\times4+3\times5+4\times5$)

$\sum \sum (xa_i+y) \times (xa_j+y)$
$= x^2 \sum \sum a_i a_j + xy (len-1)\sum a_i + len(len-1) y^2$

需要维护区间和
```cpp
struct node
{
	// 区间和，区间乘积和，乘法lz，加法lz
	int sum,ab,mul,add;
}t[N<<2];

int n,m,P;
int a[N];
// 更新
void update(int mul,int add,int be,int ed,int p)
{
	int L = ed-be+1;
	// 切记先算乘积和，因为其依托于区间和
	t[p].ab = ((t[p].ab*mul*mul + (L-1)*mul*add*t[p].sum) + L*(L-1)/2*add*add);
	t[p].sum = (t[p].sum*mul + L*add);
	t[p].mul = t[p].mul*mul;
	t[p].add = (t[p].add*mul + add);
}
// 合并
void push_up(int p)
{
	t[p].sum = (t[p<<1].sum + t[p<<1|1].sum);
	t[p].ab = ((t[p<<1].ab + t[p<<1|1].ab) + t[p<<1].sum*t[p<<1|1].sum);
}
// 下放懒标记
void push_down(int be,int ed,int p)
{
	if(t[p].mul == 1 && t[p].add == 0)	return;
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1,t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {a[be],0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int mul,int add,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,mul,add,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,mul,add,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
PII query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return {t[p].sum,t[p].ab};
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	PII res = {0,0};
	if(l <= mid)
	{
		res = query(l,r,be,mid,p<<1);
		if(mid+1 <= r)
		{
			PII tmp = query(l,r,mid+1,ed,p<<1|1);
			res = {(res.X+tmp.X),((res.Y+tmp.Y) + res.X*tmp.X)};
		}
	}
	else if(mid+1 <= r)	res = query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,1,v);// 区间加
put(l,r,v,0);// 区间乘
```

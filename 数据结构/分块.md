## 分块
本质是**暴力**

### 加速原理
对于每个查询
- 若是一块整个在查询内，则把整块的信息直接 $O(1)$ 加入
- 若是一部分个在查询内，则直接暴力 `for`，$O(\sqrt{n})$

那么整个查询 为左块 $+$ 中若干 $+$ 右块 $= \sqrt{n} + \sqrt{n} + \sqrt{n} = O(\sqrt{n})$

除了维护区间和，还可以对块排序来二分。

如求区间内大于一个数的元素和。
### code
```cpp
// 维护区间和的修改与查询
int n,q,len;
int a[N];
int L[N], R[N];// 第 i 个区间的左右端点
int belong[N];// 第 i 个元素属于哪个区间
int sum[N], lz[N];// 区间和与懒标记（类似线段树，但不完全一样）

void build(void)
{
    // 分块部分
    len = sqrt(n-1)+1;// 区间长度
    for(int i=1;i<=n;++i)   belong[i] = (i-1)/len;// 分各块属地
    int block_num = n/len+1;// 块总数
    for(int i=0;i<block_num;++i) // 左右端点
    {
        L[i] = i*len+1;
        R[i] = (i+1)*len;
    }
    R[block_num-1] = n;
    // 初始化部分
    for(int i=0;i<block_num;++i)
    {
    	for(int j=L[i];j<=R[i];++j)	sum[i] += a[j];
    }
}

void update(int l,int r,int z)
{
    // 下列代码如果把左右若为完整块情况处理进第二个for，或许会快一点点
	if(belong[l] == belong[r])// 单块特判
	{
		for(int i=l;i<=r;++i)	sum[belong[i]] += z, a[i] += z;
		return;
	}
	for(int i=l;i<=R[belong[l]];++i)	sum[belong[i]] += z, a[i] += z;
	for(int i=belong[l]+1;i<belong[r];++i)	sum[i] += len*z, lz[i] += z;
	for(int i=L[belong[r]];i<=r;++i)	sum[belong[i]] += z, a[i] += z;
}

int query(int l,int r)
{
	int res = 0;
	if(belong[l] == belong[r])
	{
		for(int i=l;i<=r;++i)	res += a[i]+lz[belong[i]];
		return res;
	}
    /*  
    因为修改在整个块上时，无法再修改到各个点上
    而修改了一个块的部分点后，其他点若是未修改，则不能把lz归零，
    那么无法判断该点是否修改过，所以保留
    */
	for(int i=l;i<=R[belong[l]];++i)	res += a[i] + lz[belong[i]];
	for(int i=belong[l]+1;i<belong[r];++i)	res += sum[i];
	for(int i=L[belong[r]];i<=r;++i)	res += a[i] + lz[belong[i]];
	return res;
}

```
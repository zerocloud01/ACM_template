## 跳表
### 介绍
跳表是为了处理**静态**查询问题的，预处理复杂度 $nlog(n)$，查询$O(1)$。所以其看上去并不如动态的如线段树有优势。

其真正优势在于与处理时间和查询时间的不对等。

事实上，在数据量只有 $10^5$，而查询数达到 $10^7$ 并且强制在线，跳表才具有**绝对优势**

最常用与 `RMQ` 问题

### 两种类型
跳表有两种
- 倍增跳表
- 根号跳表

以 RMQ 问题为例
一个长度为 $n$ 的数组，进行 $q$ 次查询

- $q \approx n$ 基本等于线段树
- $q \approx 10n$ 倍增跳表具有很大优势
- $q \approx 100n$ 根号跳表开始具有优势

### 根号跳表
预处理复杂度 $O(n \sqrt{n})$，查询$O(1)$
**原理：** 任何一个数($\le N$)都可以拆解为 $i \times \sqrt{N} + j(i,j \le \sqrt{N})$
两个st表（大小均为[$n$][$\sqrt{n}$]）
- st_sml[i][j] 存储从 $i$ 开始，长度为$j$ 的区间
- st_big[i][j] 存储从 $i$ 开始，长度为$j \times \sqrt{n}$ 的区间

对于每个查询$[l,r]$，我们都可以用一个big区间和一个sml区间拼起来得到（或者反向）

#### 优点
可以解决一些一般st表不能解决的问题
可以保证区间合并时不产生交叉/且只合并两个区间（保证$O(1)$）
**缺点：** 复杂度$O(n\sqrt{n})$

#### code
```cpp
int n,k = sqrt(n-1)+1;
int a[N];
int sts[N][k], stb[N][k];

void build(int l,int r)
{
	for(int i=1;i<=k;++i)
	{
		for(int j=1;j<=n-i+1;++j)	sts[j][i] = max(sts[j][i-1],a[j+i-1]);
	}
	for(int i=1;i<=k;++i)
	{
		for(int j=1;j<=n-i*k+1;++j)	stb[j][i] = max(stb[j][i-1],sts[j+(i-1)*k][k]);
	}
}

int query(int l,int r)
{
	int len = r-l+1;
	return max(stb[l][len/k],sts[l+len/k*k][len-len/k*k]);
}
```

### 倍增跳表
预处理复杂度 $O(n \sqrt{n})$，查询$O(1)$
也就是最常用的`st表`

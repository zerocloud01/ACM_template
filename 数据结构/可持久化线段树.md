## 可持久化线段树
### 主席树
主席树是可持久化的**权值**线段树
```cpp
struct node
{
	int cnt, ls, rs;
};

int n,q,idx,mx;
vector<int> a(N), dis, rt(N);
vector<node> t(N<<5);
int get(int x)
{
	return (lpwer_bound(dis.begin(),dis.end(),x) - dis.begin()+1);
}

void insert(int &p,int pre,int val,int be=1,int ed=mx)
{
	p = ++ idx;
	t[p] = t[pre];
	t[p].cnt ++;
	if(be == ed)	return ;
	int mid = (be+ed) >> 1;
	if(val <= mid)	insert(t[p].ls,t[pre].ls,val,be,mid);
	else	insert(t[p].rs,t[pre].rs,val,mid+1,ed);
}

int query(int lp,int rp,int k,int be=1,int ed=mx) 
{
	if(be == ed)	return be;
	int mid = (be + ed) >> 1, lcnt = t[t[rp].ls].cnt - t[t[lp].ls].cnt;
	if(k <= lcnt)	return query(t[lp].ls,t[rp].ls,k,be,mid);
	else	return query(t[lp].rs,t[rp].rs,k-lcnt,mid+1,ed);
	
}

void func(void)
{
	cin >> n >> q;
	for(int i=1;i<=n;++i)	cin >> a[i];
	for(int i=1;i<=n;++i)	dis.push_back(a[i]);
	sort(dis.begin(),dis.end());
	dis.erase(unique(dis.begin(),dis.end()),dis.end());
	mx = dis.size();
	for(int i=1;i<=n;++i)	insert(rt[i],rt[i-1],get(a[i]));
	while(q--)
	{
		int l,r,k;
		cin >> l >> r >> k;
		cout << dis[query(rt[l-1],rt[r],k)-1] << '\n';
	}
}
```
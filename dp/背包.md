## 背包
### 01背包
#### 表示容量，存储价值
```cpp
for(int i=1;i<=m;++i)// 层数
{
    for(int j=t;j>=t[i];--j)// 容量
    {
        dp[j] = max(dp[j],dp[j-t[i]]+v[i]);
    }
}
```
#### 表示价值，存储容量
```cpp
for(int i=1;i<=m;++i)// 层数
{
    for(int j=V;j>=t[i];--j)// 价值
    {
        if(dp[j-v[i]] + w[i] <= t)	dp[j] = min(dp[j],dp[j-v[i]]+w[i]);
    }
}
```
### 完全背包
```cpp
for(int i=1;i<=m;++i)// 层数
{
    for(int j=t[i];j<=t;++j)// 容量
    {
        dp[j] = max(dp[j],dp[j-t[i]]+v[i]);
    }
}
```

### 应用
#### 21ICPC上海 I
爱丽丝与鲍勃玩一款卡牌游戏。游戏开始后，鲍勃从牌堆顶展示 $n$ 张卡牌，每张卡牌有点数 $t_i$ 与价值 $v_i$。鲍勃可至多选择 $k$ 张牌使其点数翻倍，随后将所选卡牌分成点数总和相等的两组 $S$ 和 $T$（不要求用完所有牌）。爱丽丝获得 $S$ 中卡牌，鲍勃获得 $T$ 中卡牌。  
**solution**
双方希望最大化所获卡牌的价值总和 $\sum_{i \in S \cup T} v_i$，求该最大值。

因为 $i \le 100$ 且 $t_i \le 13$，且 $k \le n$，那么差值最多为 $2600$

$n \times 2600 \times k = 2.6\times 10^7$ 在时间上可以接受。
空间上有点勉强，但是可以用滚动数组优化。

那么我们构造 $dp$ 状态 
- $dp_{i,j,x}$ 表示枚举到第 $i$ 张牌，差值为 $j$，翻倍了 $x$ 次的最大方案。

因为差值有负数，所以我们**加一个 $D = 1300$ 的偏移量**即可。

对于每张牌，我们有 $5$ 种选择
不选择、$A$ 选择、$B$ 选择、$A$ 选择并翻倍、$B$ 选择并翻倍
转移时需要保证 $-2600 \le j \le 2600$ 

对于前三种，对 $x$ 没有限制
$dp_{i,j,x} \leftarrow \max (dp_{i-1,j,x},dp_{i-1,j+t_i,x}+v_i,dp_{i-1,j-t_i,x}+v_i)$

对于后两种，需要在 $x \ne 0$ 时转移
$dp_{i,j,k} \leftarrow \max(dp_{i-1,j+2t_i,x-1}+v_i,dp_{i-1,j-2t_i,x-1}+v_i)$

最后输出 $\max_{1\le x \le k} dp_{n,0,x}$ 即可

**code**
```cpp
int n,k;
int v[N],t[N];
int dp[2][M][N];

void dpmx(int &x,int y)
{
	x = max(x,y);
}

void func(void)
{
	cin >> n >> k;
	memset(dp,0xcf,sizeof dp);
	for(int i=1;i<=n;++i)	cin >> v[i] >> t[i];
	dp[0][D][0] = 0;
	int op = 0;
	for(int i=1;i<=n;++i)
	{
		for(int j=-D;j<=D;++j)
		{
			for(int x=0;x<=k;++x)
			{
				int &tmp = dp[op^1][j+D][x];
				dpmx(tmp,dp[op][j+D][x]);
				if(j+t[i] <= D)		dpmx(tmp,dp[op][j+D+t[i]][x]+v[i]);
				if(j-t[i] >= -D)	dpmx(tmp,dp[op][j+D-t[i]][x]+v[i]);
				if(x != 0)
				{
					if(j+2*t[i] <= D)	dpmx(tmp,dp[op][j+D+2*t[i]][x-1]+v[i]);
					if(j-2*t[i] >= -D)	dpmx(tmp,dp[op][j+D-2*t[i]][x-1]+v[i]);
				}
			}
		}
		op ^= 1;
	}
	int ans = 0;
	for(int i=0;i<=k;++i)	dpmx(ans,dp[op][D][i]);
	cout << ans << '\n';
}
```
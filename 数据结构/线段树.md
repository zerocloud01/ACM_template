[TOC]
## 线段树
### 模板
#### 区间修改线段树
##### 区间和
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += (ed-be+1) * z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
##### 区间RMQ
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = max(t[p<<1],t[p<<1|1]);
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res = max(res,query(l,r,be,mid,p<<1));
	if(mid+1 <= r)	res = max(res,query(l,r,mid+1,ed,p<<1|1));
	return res;
}
```
#### 单点修改线段树
单点修改不再需要lazy_tag
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += (ed-be+1) * z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
#### 权值线段树
```cpp
int n,q;
int t[N<<2];

void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 单点修改
void put(int k,int v,int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] += v;
		return ;
	}
	int mid = (be+ed) >> 1;
	if(k <= mid)	put(k,v,be,mid,p<<1);
	else	put(k,v,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询[l,r]内共有多少个数
int query_cnt(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	int mid = (be+ed) >> 1,cnt = 0;
	if(l <= mid)	cnt += query_cnt(l,r,be,mid,p<<1);
	if(mid+1 <= r)	cnt += query_cnt(l,r,mid+1,ed,p<<1|1);
	return cnt;
}
// 查询第 k 个数的值
int query_k(int k,int be=1,int ed=n,int p=1)
{
	if(be == ed)	return be;
	int mid = (be+ed) >> 1, lsum = t[p<<1];
	if(lsum >= k)	return query_k(k,be,mid,p<<1);
	else return query_k(k-lsum,mid+1,ed,p<<1|1);
}
```

### 多种 lazy_tag
#### 乘法tag 和 加法tag
$\sum xa_i+b = x\sum a_i + len\times b$
```cpp
struct node
{
	int sum,mul,add;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
### 各种区间操作
#### 加上等差数列
方案很多，如果只需要单点信息，则可以只维护差分，这里只用一棵线段树维护。

一次增加操作被断开，视为两次增减操作即可。
- $[l,x]$ 区间，$k + i \times d$
- $[x+1,r]$ 区间，$k+i \times (x+1-l) + i \times d$
```cpp
struct node
{
	// 
	int sum,k,d;
}t[N<<2];

int n,m;
int a[N];

void update(int k,int d,int be,int ed,int p)
{
	int len = ed-be+1;
	t[p].sum += len*k + len*(len-1)/2*d;
	t[p].k += k, t[p].d += d;
}

void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}

void push_down(int be=1,int ed=n,int p=1)
{
	int mid = (be + ed) >> 1;
	update(t[p].k,t[p].d,be,mid,p<<1);
	update(t[p].k+t[p].d*(mid+1-be),t[p].d,mid+1,ed,p<<1|1);
	t[p].k = t[p].d = 0;
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int k,int d,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(k+(be-l)*d,d,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,k,d,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,k,d,mid+1,ed,p<<1|1);
	push_up(p);
}

int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,k,d);// 给 l,r 加上以 k 为初始值, 方差为 d 的等差数列
query(l,r);// l,r 区间和
```

### 各种区间信息
#### 区间平方和
$\sum (xa_i+y) = x^2 \sum a_i^2 + 2xy \sum a_i + len\times y^2$

需要维护区间和
```cpp
struct node
{
    // 区间和, 平方和, 加lz，乘lz
	int sum,sq,add,mul;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sq = t[p].sq*mul*mul + t[p].sum*add*2 + (ed-be+1)*add*add;
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
	t[p].sq = t[p<<1].sq + t[p<<1|1].sq;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,0,0,1};
	if(be == ed)
	{
		t[p] = {a[be],a[be]*a[be],0,1};
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sq;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

// 区间乘
put(l,r,0,x);
// 区间加
put(l,r,x,1);
```

#### 区间乘积和
求区间 $l$ 到 $r$ 之间两两之间数字的乘积和(例如：$2,3,4,5$两两之间乘积和为 $2\times3+2\times4+2\times5+3\times4+3\times5+4\times5$)

$\sum \sum (xa_i+y) \times (xa_j+y)$
$= x^2 \sum \sum a_i a_j + xy (len-1)\sum a_i + len(len-1) y^2/2$

需要维护区间和
```cpp
struct node
{
	// 区间和，区间乘积和，乘法lz，加法lz
	int sum,ab,mul,add;
}t[N<<2];

int n,m,P;
int a[N];
// 更新
void update(int mul,int add,int be,int ed,int p)
{
	int L = ed-be+1;
	// 切记先算乘积和，因为其依托于区间和
	t[p].ab = ((t[p].ab*mul*mul + (L-1)*mul*add*t[p].sum) + L*(L-1)/2*add*add);
	t[p].sum = (t[p].sum*mul + L*add);
	t[p].mul = t[p].mul*mul;
	t[p].add = (t[p].add*mul + add);
}
// 合并
void push_up(int p)
{
	t[p].sum = (t[p<<1].sum + t[p<<1|1].sum);
	t[p].ab = ((t[p<<1].ab + t[p<<1|1].ab) + t[p<<1].sum*t[p<<1|1].sum);
}
// 下放懒标记
void push_down(int be,int ed,int p)
{
	if(t[p].mul == 1 && t[p].add == 0)	return;
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1,t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {a[be],0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int mul,int add,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,mul,add,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,mul,add,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
PII query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return {t[p].sum,t[p].ab};
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	PII res = {0,0};
	if(l <= mid)
	{
		res = query(l,r,be,mid,p<<1);
		if(mid+1 <= r)
		{
			PII tmp = query(l,r,mid+1,ed,p<<1|1);
			res.Y = (res.Y+tmp.Y) + res.X*tmp.X;
			res.X = res.X+tmp.X;
		}
	}
	else if(mid+1 <= r)	res = query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,1,v);// 区间加
put(l,r,v,0);// 区间乘
```

### 区间信息性质
#### 开方性质
一个 $\le 10^9$ 的数，最多**五次**开方到 $1$
> 就是 $\le 10^18$ 的数，也只需要 **六次**

**题面:**
第一行一个整数 $n$，代表数列中数的个数。

第二行 $n$ 个正整数，表示初始状态下数列中的数。

第三行一个整数 $m$，表示有 $m$ 次操作。

接下来 $m$ 行每行三个整数 `k l r`。

- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。
- $k=1$ 表示询问 $[l,r]$ 中各个数的和。

**思路:**
一个 $\ge$ 的数, 最多 $5$ 次开方变成 $1$, 所以最多对所有数 $5$ 次单点修改. 那么只需要维护**单点修改**和**区间查询**. 并且维护区间最值, 最大值为 $1$, 则无需再修改. 
**代码:**
```cpp
#include<bits/stdc++.h>
#define Start cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)
#define PII pair<int,int> 
#define x first
#define y second
#define ull unsigned long long
#define int long long
using namespace std;

const int M = 1000000007;
const int N = 1e5 + 10;

int n,m;
vector<int> a(N),t(N<<2),tmx(N<<2);

void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
	tmx[p] = max(tmx[p<<1],tmx[p<<1|1]);
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		tmx[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1),build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = sqrt(t[p]);
		tmx[p] = sqrt(tmx[p]);
		return ;
	}
	int mid = (be + ed) >> 1;
	if(l <= mid && tmx[p] > 1)	put(l,r,be,mid,p<<1);
	if(mid+1 <= r && tmx[p] > 1)	put(l,r,mid+1,ed,p<<1|1);
	push_up(p);
}

int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

void func(void);

signed main(void)
{
	Start;
	int _ = 1;
	// cin >> _;
	while(_--)	func();
	return 0;
}

void func(void)
{
	cin >> n;
	for(int i=1;i<=n;++i)	cin >> a[i];
	build_tree();
	cin >> m;
	while(m--)
	{
		bool op;	cin >> op;
		int l,r;	cin >> l >> r;
		if(l > r)	swap(l,r);
		if(op)	cout << query(l,r) << '\n';
		else	put(l,r);// 一次结束当然比循环一次要快了
	}
}
```

### 开多棵线段树
**此处是bitset优化**
**题面:**
色板长度为 $L$，$L$ 是一个正整数，所以我们可以均匀地将它划分成 $L$ 块 $1$ 厘米长的小方格。并从左到右标记为 $1, 2, \dots L$。

现在色板上只有一个颜色，老师告诉阿宝在色板上只能做两件事：

1. `C A B C` 指在 $A$ 到 $B$ 号方格中涂上颜色 $C$。
2. `P A B` 指老师的提问：$A$ 到 $B$ 号方格中有几种颜色。

学校的颜料盒中一共有 $T$ 种颜料。为简便起见，我们把他们标记为 $1, 2, \dots T$. 开始时色板上原有的颜色就为 $1$ 号色。 面对如此复杂的问题，阿宝向你求助，你能帮助他吗？

**输入格式:**
第一行有3个整数 $L (1 \le L \le 10^5), T (1 \le T \le 30) 和 O (1 \le O \le 10^5)$。 在这里 $O$ 表示事件数。 

接下来 $O$ 行, 每行以 `C A B C` 或 `P A B` 得形式表示所要做的事情（这里 $A, B, C$ 为整数, 可能 $A> B$，这样的话需要你交换 $A$ 和 $B$）。
**输出格式:**
对于老师的提问，做出相应的回答。每行一个整数。

**代码:**
```cpp
#include<bits/stdc++.h>
#define Start cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)
#define PII pair<int,int> 
#define x first
#define y second
#define ull unsigned long long
#define ll long long
using namespace std;

const int M = 1000000007;
const int N = 1e5 + 10;

int n,k,q;
vector<bitset<1000>> t(N<<2);
vector<int> lz(N<<2);
// vector<vector<bool>> t(40,vector<bool>(N<<2));
// vector<int> lz(N<<2);

void update(int col,int be,int ed,int p)
{
	// cout << col << ' ' << be << ' ' << ed << '\n';
	t[p].reset();	t[p].set(col);
	lz[p] = col;
}

void push_up(int p)
{
	int lp = p<<1, rp = p<<1|1;
	t[p] = t[p<<1] | t[p<<1|1];
}

void push_down(int be,int ed,int p)
{
	if(lz[p] == 0)	return ;
	int mid = (be+ed) >> 1;
	update(lz[p],be,mid,p<<1);
	update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p].set(1);
		return;
	}
	int mid = (be+ed) >> 1;
	build_tree(be,mid,p<<1);
	build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int col,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(col,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be+ed) >> 1;
	if(l <= mid)	put(l,r,col,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,col,mid+1,ed,p<<1|1);
	push_up(p);
	// cout << t[col][p] << ' ';
}

bitset<1000> query(int l,int r,int be=1,int ed=n,int p=1)
{
	bitset<1000> res = 0;
	if(l <= be && ed <= r)
	{
		return t[p];
	}
	push_down(be,ed,p);
	int mid = (be+ed) >> 1;
	if(l <= mid)	res |= query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res |= query(l,r,mid+1,ed,p<<1|1);
	return res;
}

void func(void);

signed main(void)
{
	Start;
	int _  = 1;
	while(_--)	func();
	return 0;
}

void func(void)
{
	cin >> n >> k >> q;
	build_tree();
	while(q--)
	{
		char op;
		int l,r;
		cin >> op >> l >> r;
		if(l > r)	swap(l,r);
		if(op == 'C')
		{
			int col;	cin >> col;
			put(l,r,col);
		}
		else 
		{
			int ans = 0;
			cout << query(l,r).count() << '\n';
			// cout << ans << '\n';
		}
	}
}
```
[TOC]
## 线段树
### 模板
#### 区间修改线段树
##### 区间和
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += (ed-be+1) * z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query_sum(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
##### 区间RMQ
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = max(t[p<<1],t[p<<1|1]);
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res = max(res,query(l,r,be,mid,p<<1));
	if(mid+1 <= r)	res = max(res,query(l,r,mid+1,ed,p<<1|1));
	return res;
}
```
#### 单点修改线段树
单点修改不再需要lazy_tag
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += (ed-be+1) * z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
#### 权值线段树
```cpp

int n,q;
int t[N<<2];

void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 单点修改
void put(int k,int v,int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] += v;
		return ;
	}
	int mid = (be+ed) >> 1;
	if(x <= mid)	add(k,v,be,mid,p<<1);
	else	add(k,v,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询[l,r]内共有多少个数
int query_cnt(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	int mid = (be+ed) >> 1,cnt = 0;
	if(l <= mid)	cnt += query_cnt(l,r,be,mid,p<<1);
	if(mid+1 <= r)	cnt += query_cnt(l,r,mid+1,ed,p<<1|1);
	return cnt;
}
// 查询第 k 个数的值
int query_k(int k,int be=1,int ed=n,int p=1)
{
	if(be == ed)	return be;
	int mid = (be+ed) >> 1, lsum = t[p<<1];
	if(lsum >= k)	return query_k(k,be,mid,p<<1);
	else return query_k(k-lsum,mid+1,ed,p<<1|1);
}
```

### 多种 lazy_tag
#### 乘法tag 和 加法tag
$\sum xa_i+b = x\sum a_i + len\times b$
```cpp
struct node
{
	int sum,mul,add;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
### 各种区间操作
#### 加上等差数列
方案很多，如果只需要单点信息，则可以只维护差分，这里只用一棵线段树维护。

一次增加操作被断开，视为两次增减操作即可。
- $[l,x]$ 区间，$k + i \times d$
- $[x+1,r]$ 区间，$k+i \times (x+1-l) + i \times d$
```cpp
struct node
{
	// 
	int sum,k,d;
}t[N<<2];

int n,m;
int a[N];

void update(int k,int d,int be,int ed,int p)
{
	int len = ed-be+1;
	t[p].sum += len*k + len*(len-1)/2*d;
	t[p].k += k, t[p].d += d;
}

void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}

void push_down(int be=1,int ed=n,int p=1)
{
	int mid = (be + ed) >> 1;
	update(t[p].k,t[p].d,be,mid,p<<1);
	update(t[p].k+t[p].d*(mid+1-be),t[p].d,mid+1,ed,p<<1|1);
	t[p].k = t[p].d = 0;
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int k,int d,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(k+(be-l)*d,d,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,k,d,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,k,d,mid+1,ed,p<<1|1);
	push_up(p);
}

int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,k,d);// 给 l,r 加上以 k 为初始值, 方差为 d 的等差数列
query(l,r);// l,r 区间和
```

### 各种区间信息
#### 区间平方和
$\sum (xa_i+y) = x^2 \sum a_i^2 + 2xy \sum a_i + len\times y^2$

需要维护区间和
```cpp
struct node
{
    // 区间和, 平方和, 加lz，乘lz
	int sum,sq,add,mul;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sq = t[p].sq*mul*mul + t[p].sum*add*2 + (ed-be+1)*add*add;
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
	t[p].sq = t[p<<1].sq + t[p<<1|1].sq;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,0,0,1};
	if(be == ed)
	{
		t[p] = {a[be],a[be]*a[be],0,1};
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sq;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

// 区间乘
put(l,r,0,x);
// 区间加
put(l,r,x,1);
```

#### 区间乘积和
求区间 $l$ 到 $r$ 之间两两之间数字的乘积和(例如：$2,3,4,5$两两之间乘积和为 $2\times3+2\times4+2\times5+3\times4+3\times5+4\times5$)

$\sum \sum (xa_i+y) \times (xa_j+y)$
$= x^2 \sum \sum a_i a_j + xy (len-1)\sum a_i + len(len-1) y^2$

需要维护区间和
```cpp
struct node
{
	// 区间和，区间乘积和，乘法lz，加法lz
	int sum,ab,mul,add;
}t[N<<2];

int n,m,P;
int a[N];
// 更新
void update(int mul,int add,int be,int ed,int p)
{
	int L = ed-be+1;
	// 切记先算乘积和，因为其依托于区间和
	t[p].ab = ((t[p].ab*mul*mul + (L-1)*mul*add*t[p].sum) + L*(L-1)/2*add*add);
	t[p].sum = (t[p].sum*mul + L*add);
	t[p].mul = t[p].mul*mul;
	t[p].add = (t[p].add*mul + add);
}
// 合并
void push_up(int p)
{
	t[p].sum = (t[p<<1].sum + t[p<<1|1].sum);
	t[p].ab = ((t[p<<1].ab + t[p<<1|1].ab) + t[p<<1].sum*t[p<<1|1].sum);
}
// 下放懒标记
void push_down(int be,int ed,int p)
{
	if(t[p].mul == 1 && t[p].add == 0)	return;
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1,t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {a[be],0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int mul,int add,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,mul,add,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,mul,add,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
PII query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return {t[p].sum,t[p].ab};
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	PII res = {0,0};
	if(l <= mid)
	{
		res = query(l,r,be,mid,p<<1);
		if(mid+1 <= r)
		{
			PII tmp = query(l,r,mid+1,ed,p<<1|1);
			res = {(res.X+tmp.X),((res.Y+tmp.Y) + res.X*tmp.X)};
		}
	}
	else if(mid+1 <= r)	res = query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,1,v);// 区间加
put(l,r,v,0);// 区间乘
```
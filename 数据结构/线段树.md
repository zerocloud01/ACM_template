## 线段树
### 模板
#### 区间修改线段树
```cpp
int n;
int a[N],t[N<<2],lz[N<<2];
// 更新节点
void update(int z,int be,int ed,int p)
{
	t[p] += (ed-be+1) * z;
	lz[p] += z;
}
// 合并
void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(lz[p],be,mid,p<<1),update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 修改
void put(int l,int r,int z,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(z,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,z,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,z,mid+1,ed,p<<1|1);
	push_up(p);
}
// 查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```

### 多种 lazy_tag
#### 乘法tag 和 加法tag
$\sum xa_i+b = x\sum a_i + len\times b$
```cpp
struct node
{
	int sum,mul,add;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}
```
### 各种区间操作
#### 区间加等差数列
方案很多，如果只需要单点信息，则可以只维护差分，这里只用一棵线段树维护。

一次增加操作被断开，视为两次增减操作即可。
- $[l,x]$ 区间，$k + i \times d$
- $[x+1,r]$ 区间，$k+i \times (x+1-l) + i \times d$
```cpp
struct node
{
	// 
	int sum,k,d;
}t[N<<2];

int n,m;
int a[N];

void update(int k,int d,int be,int ed,int p)
{
	int len = ed-be+1;
	t[p].sum += len*k + len*(len-1)/2*d;
	t[p].k += k, t[p].d += d;
}

void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
}

void push_down(int be=1,int ed=n,int p=1)
{
	int mid = (be + ed) >> 1;
	update(t[p].k,t[p].d,be,mid,p<<1);
	update(t[p].k+t[p].d*(mid+1-be),t[p].d,mid+1,ed,p<<1|1);
	t[p].k = t[p].d = 0;
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int k,int d,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(k+(be-l)*d,d,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,k,d,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,k,d,mid+1,ed,p<<1|1);
	push_up(p);
}

int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sum;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,k,d);// 给 l,r 加上以 k 为初始值, 方差为 d 的等差数列
query(l,r);// l,r 区间和
```

### 各种区间信息
大部分是数学题，推导出式子得出需要维护的信息即可。
#### 区间平方和
$\sum (xa_i+y) = x^2 \sum a_i^2 + 2xy \sum a_i + len\times y^2$

需要维护区间和
```cpp
struct node
{
    // 区间和, 平方和, 加lz，乘lz
	int sum,sq,add,mul;
}t[N<<2];

int n,m;
int a[N];
// 更新节点
void update(int mul,int add,int be,int ed,int p)
{
	t[p].sq = t[p].sq*mul*mul + t[p].sum*add*2 + (ed-be+1)*add*add;
	t[p].sum = t[p].sum*mul + (ed-be+1) * add;
	t[p].mul *= mul, t[p].add = t[p].add*mul+add;
}
// 合并
void push_up(int p)
{
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum;
	t[p].sq = t[p<<1].sq + t[p<<1|1].sq;
}
// 下放lazy_tag
void push_down(int be,int ed,int p)
{
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1, t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {0,0,0,1};
	if(be == ed)
	{
		t[p] = {a[be],a[be]*a[be],0,1};
		return;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int add,int mul,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,add,mul,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,add,mul,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p].sq;
	push_down(be,ed,p);
	int mid = (be + ed) >> 1,res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

// 区间乘
put(l,r,0,x);
// 区间加
put(l,r,x,1);
```

#### 区间乘积和
求区间 $l$ 到 $r$ 之间两两之间数字的乘积和(例如：$2,3,4,5$两两之间乘积和为 $2\times3+2\times4+2\times5+3\times4+3\times5+4\times5$)

$\sum \sum (xa_i+y) \times (xa_j+y)$
$= x^2 \sum \sum a_i a_j + xy (len-1)\sum a_i + len(len-1) y^2/2$

需要维护区间和
```cpp
struct node
{
	// 区间和，区间乘积和，乘法lz，加法lz
	int sum,ab,mul,add;
}t[N<<2];

int n,m,P;
int a[N];
// 更新
void update(int mul,int add,int be,int ed,int p)
{
	int L = ed-be+1;
	// 切记先算乘积和，因为其依托于区间和
	t[p].ab = ((t[p].ab*mul*mul + (L-1)*mul*add*t[p].sum) + L*(L-1)/2*add*add);
	t[p].sum = (t[p].sum*mul + L*add);
	t[p].mul = t[p].mul*mul;
	t[p].add = (t[p].add*mul + add);
}
// 合并
void push_up(int p)
{
	t[p].sum = (t[p<<1].sum + t[p<<1|1].sum);
	t[p].ab = ((t[p<<1].ab + t[p<<1|1].ab) + t[p<<1].sum*t[p<<1|1].sum);
}
// 下放懒标记
void push_down(int be,int ed,int p)
{
	if(t[p].mul == 1 && t[p].add == 0)	return;
	int mid = (be + ed) >> 1;
	update(t[p].mul,t[p].add,be,mid,p<<1), update(t[p].mul,t[p].add,mid+1,ed,p<<1|1);
	t[p].mul = 1,t[p].add = 0;
}
// 初始化
void build_tree(int be=1,int ed=n,int p=1)
{
	t[p] = {a[be],0,1,0};
	if(be == ed)
	{
		t[p].sum = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间修改
void put(int l,int r,int mul,int add,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(mul,add,be,ed,p);
		return;
	}
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	if(l <= mid)	put(l,r,mul,add,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,mul,add,mid+1,ed,p<<1|1);
	push_up(p);
}
// 区间查询
PII query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return {t[p].sum,t[p].ab};
	push_down(be,ed,p);
	int mid = (be + ed) >> 1;
	PII res = {0,0};
	if(l <= mid)
	{
		res = query(l,r,be,mid,p<<1);
		if(mid+1 <= r)
		{
			PII tmp = query(l,r,mid+1,ed,p<<1|1);
			res.Y = (res.Y+tmp.Y) + res.X*tmp.X;
			res.X = res.X+tmp.X;
		}
	}
	else if(mid+1 <= r)	res = query(l,r,mid+1,ed,p<<1|1);
	return res;
}

put(l,r,1,v);// 区间加
put(l,r,v,0);// 区间乘
```

### 区间信息性质
#### 开方性质
一个 $\le 10^9$ 的数，最多**五次**开方到 $1$
> 就是 $\le 10^{18}$ 的数，也只需要 **六次**

**题面大意:**
第一行一个整数 $n$，代表数列中数的个数。

第二行 $n$ 个正整数，表示初始状态下数列中的数。

第三行一个整数 $m$，表示有 $m$ 次操作。

接下来 $m$ 行每行三个整数 `k l r`。

- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。
- $k=1$ 表示询问 $[l,r]$ 中各个数的和。

**思路:**
一个 $\ge$ 的数, 最多 $5$ 次开方变成 $1$, 所以最多对所有数 $5$ 次单点修改. 那么只需要维护**单点修改**和**区间查询**. 并且维护区间最值, 最大值为 $1$, 则无需再修改. 
**代码:**
```cpp
int n,m;
vector<int> a(N),t(N<<2),tmx(N<<2);

void push_up(int p)
{
	t[p] = t[p<<1] + t[p<<1|1];
	tmx[p] = max(tmx[p<<1],tmx[p<<1|1]);
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = a[be];
		tmx[p] = a[be];
		return ;
	}
	int mid = (be + ed) >> 1;
	build_tree(be,mid,p<<1),build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = sqrt(t[p]);
		tmx[p] = sqrt(tmx[p]);
		return ;
	}
	int mid = (be + ed) >> 1;
	if(l <= mid && tmx[p] > 1)	put(l,r,be,mid,p<<1);
	if(mid+1 <= r && tmx[p] > 1)	put(l,r,mid+1,ed,p<<1|1);
	push_up(p);
}

int query(int l,int r,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)	return t[p];
	int mid = (be + ed) >> 1, res = 0;
	if(l <= mid)	res += query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res += query(l,r,mid+1,ed,p<<1|1);
	return res;
}

void func(void);

void func(void)
{
	cin >> n;
	for(int i=1;i<=n;++i)	cin >> a[i];
	build_tree();
	cin >> m;
	while(m--)
	{
		bool op;	cin >> op;
		int l,r;	cin >> l >> r;
		if(l > r)	swap(l,r);
		if(op)	cout << query(l,r) << '\n';
		else	put(l,r);
	}
}
```

### 开多棵线段树
**此处是bitset优化**
[P1558 色板游戏](https://www.luogu.com.cn/problem/P1558)
**题面大意:**
一个长度为 $n \le 10^5$序列，可以被涂成 $30$ 种颜色。
维护区间修改：一个区间被修改成某种颜色。
区间查询：一个区间中有几种颜色。

开 $30$ 棵线段树维护每种颜色出现的区间。用状压维护每种颜色会方便一点。

**代码:**
```cpp
#include<bits/stdc++.h>
#define Start cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)
#define PII pair<int,int> 
#define x first
#define y second
#define ull unsigned long long
#define ll long long
using namespace std;

const int M = 1000000007;
const int N = 1e5 + 10;

int n,k,q;
vector<bitset<32>> t(N<<2);
vector<int> lz(N<<2);

void update(int col,int be,int ed,int p)
{
	t[p].reset();	t[p].set(col);
	lz[p] = col;
}

void push_up(int p)
{
	int lp = p<<1, rp = p<<1|1;
	t[p] = t[p<<1] | t[p<<1|1];
}

void push_down(int be,int ed,int p)
{
	if(lz[p] == 0)	return ;
	int mid = (be+ed) >> 1;
	update(lz[p],be,mid,p<<1);
	update(lz[p],mid+1,ed,p<<1|1);
	lz[p] = 0;
}

void build_tree(int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p].set(1);
		return;
	}
	int mid = (be+ed) >> 1;
	build_tree(be,mid,p<<1);
	build_tree(mid+1,ed,p<<1|1);
	push_up(p);
}

void put(int l,int r,int col,int be=1,int ed=n,int p=1)
{
	if(l <= be && ed <= r)
	{
		update(col,be,ed,p);
		return ;
	}
	push_down(be,ed,p);
	int mid = (be+ed) >> 1;
	if(l <= mid)	put(l,r,col,be,mid,p<<1);
	if(mid+1 <= r)	put(l,r,col,mid+1,ed,p<<1|1);
	push_up(p);
}

bitset<32> query(int l,int r,int be=1,int ed=n,int p=1)
{
	bitset<32> res = 0;
	if(l <= be && ed <= r)
	{
		return t[p];
	}
	push_down(be,ed,p);
	int mid = (be+ed) >> 1;
	if(l <= mid)	res |= query(l,r,be,mid,p<<1);
	if(mid+1 <= r)	res |= query(l,r,mid+1,ed,p<<1|1);
	return res;
}

void func(void)
{
	cin >> n >> k >> q;
	build_tree();
	while(q--)
	{
		char op;
		int l,r;
		cin >> op >> l >> r;
		if(l > r)	swap(l,r);
		if(op == 'C')
		{
			int col;	cin >> col;
			put(l,r,col);
		}
		else 
		{
			int ans = 0;
			cout << query(l,r).count() << '\n';
			// cout << ans << '\n';
		}
	}
}
```

#### 线段树二分
##### 无区间限制二分
二分整个区间，只有二分一个限制。

[25CCPC福建邀请赛F](https://codeforces.com/gym/105977)
二分离线维护偏序+扫描线
题意：
给出n个二元组 $(x_i,y_i)$，你需要回答 $q$ 个询问，每个询问给出闭区间 $[l,r]$，请回答满足以下条件的整数 $j$ 数量：
• $l \le j \le r$
• 不存在 $l \le k \le r,k \ne j$，使得 $x_k \ge x_j$ 且 $y_k \ge y_j$

线段树二分维护离线 $i$ 左右第一个满足条件的索引。
然后用扫描线维护贡献，设左右分别为 $l_i,r_i$那么在 $[l_i+1,i] \times [i,r_i-1]$ 产生贡献。扫描线用树状数组维护差分，然后只需要单点修改即可。
```cpp
struct TIII
{
	int x,y,id;
	bool operator < (const TIII &i)	const
	{
		return (x == i.x ? (y == i.y ? id < i.id : y > i.y) : x > i.x);
	}
};

int n,q;
int x[N],y[N],t[N<<2],l[N],r[N];
int line[N];
vector<TIII> et[N];
vector<PII> eq[N];
vector<int> tp[N];

void put(int k,int be=1,int ed=n,int p=1)
{
	if(be == ed)
	{
		t[p] = y[k];
		return;
	}
	int mid = (be + ed) >> 1;
	if(k <= mid)	put(k,be,mid,p<<1);
	else	put(k,mid+1,ed,p<<1|1);
	t[p] = max(t[p<<1],t[p<<1|1]);
}

int query_L(int k,int be=1,int ed=n,int p=1)
{
	if(t[p] < y[k] || be > k-1)	return 0;
	if(be == ed)	return be;
	int mid = (be + ed) >> 1, tmp = 0;
	if(mid+1 <= k-1)	tmp = query_L(k,mid+1,ed,p<<1|1);
	if(tmp)	return tmp;
	else	return query_L(k,be,mid,p<<1);
}

int query_R(int k,int be=1,int ed=n,int p=1)
{
	if(t[p] < y[k] || ed < k+1)	return 0;
	if(be == ed)	return be;
	int mid = (be + ed) >> 1, tmp = 0;
	if(k+1 <= mid)	tmp = query_R(k,be,mid,p<<1);
	if(tmp)	return tmp;
	else	return query_R(k,mid+1,ed,p<<1|1);
}
// 树状数组
void put_bit(int l,int r,int z)
{
	for(int i=l;i<=n;i+=(i&-i))	line[i] += z;
	for(int i=r+1;i<=n;i+=(i&-i))	line[i] -= z;
}

int query_bit(int p)
{
	int res = 0;
	for(int i=p;i>=1;i-=(i&-i))	res += line[i];
	return res;
}

void func(void)
{
	cin >> n >> q;
	for(int i=1;i<=n;++i)	cin >> x[i];
	for(int i=1;i<=n;++i)	cin >> y[i];
	for(int i=1;i<=n;++i)
	{
		tp[++ x[i]].push_back(i);
		y[i] ++;
	}
	for(int i=N;i>=0;--i)
	{
		for(auto &id : tp[i])	put(id);
		for(auto &id : tp[i])
		{
			l[id] = query_L(id);
			r[id] = query_R(id);
			if(!r[id])	r[id] = n+1;
		}
	}
	vector<int> ans(q+1);
	for(int i=1;i<=q;++i)
	{
		int u,v;	cin >> u >> v;
		eq[v].push_back({u,i});
	}
	for(int i=1;i<=n;++i)
	{
		if(l[i]+1 <= i && i <= r[i]-1)
		{
			et[i].push_back({l[i]+1,i,1});
			et[r[i]].push_back({l[i]+1,i,-1});
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(auto &[X,Y,val] : et[i])	put_bit(X,Y,val);
		for(auto &[j,id] : eq[i])	ans[id] = query_bit(j);
	}
	for(int i=1;i<=q;++i)	cout << ans[i] << '\n';
}
```

##### 限制区间二分
$l,r$ 需要由多个区间合并拼合，那么需要用一些手段判断需要找的信息在 $l,r$ 的哪个区间中。
**题意**  
有 $n$ 头猪，每头猪有一个评分 $a_i$。若选 $k$ 头猪 $p_1, p_2, \dots, p_k$ 组队，队伍评分为这些猪评分的**按位与**结果。  
$q$ 次询问，分三种：  
- $1\ l\ r\ x$：将 $a[l \dots r]$ 每个数 **与 $x$** 后更新。  
- $2\ s\ x$：将 $a_s$ 改为 $x$。  
- $3\ l\ r$：从区间 $[l, r]$ 中选所有猪，必须**恰好去掉一头**，求剩下猪组队的**最大评分**。

```cpp
const int N = 1e6 + 10;
const int D = (1ll<<63)-1;

struct node
{
    int sum,mk,lz;
}t[N<<2];

int n,q;
int a[N];

void update(int len,int z,int p)
{
    t[p].mk = (t[p].mk&z)|(len == 1 ? ~z : 0);
    t[p].sum &= z;
    t[p].lz &= z;
}

void push_up(int p)
{
    t[p].sum = t[p<<1].sum&t[p<<1|1].sum;
    t[p].mk = (t[p<<1].sum&t[p<<1|1].mk)|(t[p<<1].mk&t[p<<1|1].sum);
}

void push_down(int be,int ed,int p)
{
    int mid = (be+ed) >> 1;
    update(mid-be+1,t[p].lz,p<<1), update(ed-mid,t[p].lz,p<<1|1);
    t[p].lz = D;
}

void build_tree(int be=1,int ed=n,int p=1)
{
    t[p].lz = D;
    if(be == ed)
    {
        t[p].sum = a[be];
        t[p].mk = ~a[be];
        return;
    }
    int mid = (be + ed) >> 1;
    build_tree(be,mid,p<<1), build_tree(mid+1,ed,p<<1|1);
    push_up(p);
}

void put1(int l,int r,int z,int be=1,int ed=n,int p=1)
{
    if(l <= be && ed <= r)
    {
        update(ed-be+1,z,p);
        return;
    }
    push_down(be,ed,p);
    int mid = (be + ed) >> 1;
    if(l <= mid)    put1(l,r,z,be,mid,p<<1);
    if(mid+1 <= r)  put1(l,r,z,mid+1,ed,p<<1|1);
    push_up(p);
}

void put2(int k,int z,int be=1,int ed=n,int p=1)
{
    if(be == ed)
    {
        t[p].sum = z;
        t[p].mk = ~z;
        return;
    }
    push_down(be,ed,p);
    int mid = (be + ed) >> 1;
    if(k <= mid)    put2(k,z,be,mid,p<<1);
    else            put2(k,z,mid+1,ed,p<<1|1);
    push_up(p);
}

PII query(int l,int r,int be=1,int ed=n,int p=1)
{
    if(l <= be && ed <= r)  return {t[p].sum,t[p].mk};
    push_down(be,ed,p);
    int mid = (be + ed) >> 1; PII res = {D,0};
    if(l <= mid)
    {
        PII tmp = query(l,r,be,mid,p<<1);
        res.Y = (res.X&tmp.Y)|(tmp.X&res.Y);
        res.X &= tmp.X;
    }
    if(mid+1 <= r)
    {
        PII tmp = query(l,r,mid+1,ed,p<<1|1);
        res.Y = (res.X&tmp.Y)|(tmp.X&res.Y);
        res.X &= tmp.X;
    }
    return res;
}

int query_id(int l,int r,int k,int be=1,int ed=n,int p=1)
{
    if(be == ed)    return be;
    push_down(be,ed,p);
    int mid = (be + ed) >> 1;
    bool op = false;
    if(l <= mid)
    {
        if(l <= be && mid+1 <= r)  op = (t[p<<1].mk>>k)&1;
        else    op = (query(l,min(mid,r),be,mid,p<<1).Y>>k)&1;
    }
    return (op ? query_id(l,r,k,be,mid,p<<1) : query_id(l,r,k,mid+1,ed,p<<1|1));
}

void func(void)
{
	cin >> n >> q;
    for(int i=1;i<=n;++i)   cin >> a[i];
    build_tree();
    while(q --)
    {
        int op; cin >> op;
        if(op == 1)
        {
            int l,r,x;  cin >> l >> r >> x;
            put1(l,r,x);
        }
        else if(op == 2)
        {
            int s,x;    cin >> s >> x;
            put2(s,x);
        }
        else
        {
            int l,r;    cin >> l >> r;
            auto [sum,mk] = query(l,r);
            if(!mk) cout << sum << '\n';
            else
            {
                int t = 63 - __builtin_clzll(mk);
                int p = query_id(l,r,t), ans = D;
                if(p-1 >= l)    ans &= query(l,p-1).X;
                if(p+1 <= r)    ans &= query(p+1,r).X;
                cout << ans << '\n';
            }
        }
    }
}
```
## 启发式合并
启发式算法是基于人类的经验和直观感觉，对一些算法的优化。

简单来说就是把较小/较低的合并到较大/较高，典型有 dsu on tree和并查集

### 应用

#### 21ICPC上海M
一个无向连通图，包含 $n$ 座城市与 $m$ 条连接城市的无向道路。作为玩家，你将在世界图上展开人生游戏。
初始时你位于第 $x$ 座城市，拥有 $k$ 点社交能力。你可以通过生活与工作获取社交能力——在第 $i$ 座城市生活工作可获得 $a_i$ 点社交能力，但每座城市仅可获取一次。你希望通过周游世界获取更多能力值。然而通行道路需满足条件：第 $i$ 条道路要求至少具备 $w_i$ 点社交能力方可通行（通行过程不会消耗能力值）。
游戏包含 $q$ 个存档。每个存档会给定初始城市与社交能力值（尚未在任何城市生活工作）。请针对每个存档，计算最终能获得的最大社交能力值并输出。

**solution**
对于同一个节点的存档，排序后符合最终答案有单调性。即较小的存档可以获得的能力更少，且随存档 $k$ 递增

那么我们把边从小到大枚举，可以按顺序剔除存档。

我们尝试讨论

在只有两个点和一条边和两个询问时时，设点为 $p,q$，
- 如果 $a_p+k_p < w$，无法从 $p \rightarrow q$，那么这时存档 $k_p$ 的答案已经得到。直接存入并且删除存档即可。
- 如果 $a_p + k_p \ge w$，可以从 $p \rightarrow q$，这时可以尝试把两个节点合并。
	具体的，$a_p \leftarrow a_p + a_q$，然后将存档都记录到 $p$ 上。
	> 但是如果 $q$ 无法到 $p$，则无法将 $q$ 的存档加到 $p$ 上，因为在尝试合并之前存档已被删除。

那么对于两堆点和一条边来说也是一样的。
对于一堆点，取用之前必然已经成功合并，这一堆点之间互相可达，我们借助并查集直接取出“根节点”。并且在取用之前把其他节点的信息记录在根节点中（$\sum a_i$ 和 $k_i$）

我们尝试连接这两堆点，连接之前需要计算每堆的 $\sum a_i + k_i$。

根据上述内容所说，同一个节点存档有单调性，那么同一堆节点存档排序后也具有单调性。设当前存档最小节点为 $p$，大一个的节点为 $q$，为了动态维护存档顺序，使用`std::set`/`std::priority_queue`
- 如果 $\sum a + k_p < w$，记录 $x_p$ 的答案然后尝试使用 $q$ 来连接。
- 如果 $\sum a + k_p \ge w$，$p,q$ 以及更大的存档都可以到达另一堆点。

具体我们要如何合并？对于 $n \le 10^5$ 的点，暴力合并复杂度无法接受。
我们使用启发式合并，将小点集合并到大点集即可。

这时又有一个问题，我们怎么保证枚举的边的顺序合理，每次删除最先无法继续合并的存档？

只需要对边排个序即可。因为存档的单调性，边从小到大限制存档就可以保证优先删除结束存档。

**code**
```cpp
struct edge
{
	int x,y,w;
	bool operator < (const edge &i)	const
	{
		return w < i.w;
	}
};

int n,m,q;
int a[N],ans[N],rt[N];
priority_queue<PII,vector<PII>,greater<PII>> pq[N];

int get(int x)
{
	return rt[x] = (x == rt[x] ? x : get(rt[x]));
}

void func(void)
{
	cin >> n >> m >> q;
	vector<edge> e(m+1);
	for(int i=1;i<=n;++i)
	{
		cin >> a[i];
		rt[i] = i;
	}
	for(int i=1;i<=m;++i)	cin >> e[i].x >> e[i].y >> e[i].w;
	sort(e.begin()+1,e.end());
	for(int i=1;i<=q;++i)
	{
		int x,k;	cin >> x >> k;
		pq[x].push({k,i});
	}
	for(int i=1;i<=m;++i)
	{
		auto [x,y,w] = e[i];
		x = get(x), y = get(y);
		if(x == y)	continue;
		while(pq[x].size() && pq[x].top().X+a[x] < w)
		{
			auto [v,id] = pq[x].top();	pq[x].pop();
			ans[id] = v+a[x];
		}
		while(pq[y].size() && pq[y].top().X+a[y] < w)
		{
			auto [v,id] = pq[y].top();	pq[y].pop();
			ans[id] = v+a[y];
		}
		if(pq[x].size() > pq[y].size())	swap(x,y);
		while(pq[x].size())
		{
			pq[y].push(pq[x].top());
			pq[x].pop();
		}
		rt[x] = y;
		a[y] += a[x];
	}
	for(int i=1;i<=n;++i)
	{
		int x = get(i);
		while(pq[x].size())
		{
			auto [v,id] = pq[x].top();	pq[x].pop();
			ans[id] = v+a[x];
		}
	}
	for(int i=1;i<=q;++i)	cout << ans[i] << '\n';
}
```
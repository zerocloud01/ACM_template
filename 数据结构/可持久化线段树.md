## 可持久化线段树
### 主席树
主席树是可持久化的**权值**线段树
```cpp
struct node
{
	int cnt, ls, rs;
};

int n,q,idx,mx;
vector<int> a(N), dis, rt(N);
vector<node> t(N<<5);
int get(int x)
{
	return (lower_bound(dis.begin(),dis.end(),x) - dis.begin()+1);
}

void insert(int &p,int pre,int val,int be=1,int ed=mx)
{
	p = ++ idx;
	t[p] = t[pre];
	t[p].cnt ++;
	if(be == ed)	return ;
	int mid = (be+ed) >> 1;
	if(val <= mid)	insert(t[p].ls,t[pre].ls,val,be,mid);
	else	insert(t[p].rs,t[pre].rs,val,mid+1,ed);
}

int query(int lp,int rp,int k,int be=1,int ed=mx) 
{
	if(be == ed)	return be;
	int mid = (be + ed) >> 1, lcnt = t[t[rp].ls].cnt - t[t[lp].ls].cnt;
	if(k <= lcnt)	return query(t[lp].ls,t[rp].ls,k,be,mid);
	else	return query(t[lp].rs,t[rp].rs,k-lcnt,mid+1,ed);
	
}

void func(void)
{
	cin >> n >> q;
	for(int i=1;i<=n;++i)	cin >> a[i];
	for(int i=1;i<=n;++i)	dis.push_back(a[i]);
	sort(dis.begin(),dis.end());
	dis.erase(unique(dis.begin(),dis.end()),dis.end());
	mx = dis.size();
	for(int i=1;i<=n;++i)	insert(rt[i],rt[i-1],get(a[i]));
	while(q--)
	{
		int l,r,k;
		cin >> l >> r >> k;
		cout << dis[query(rt[l-1],rt[r],k)-1] << '\n';
	}
}
```

### 题目
#### 区间数的种类

对于一个询问 $l,r$：
- 如果这个数只出现一次，那么它的上一个数要么不存在，要么在 $l$ 之前
- 如果出现多次，那么第二个以及之后的数，他们的前一个数都在 $[l,r]$ 范围内。

那么我们用主席树维护每个数上一次出现的位置。
$l,r$ 区间的数，指向 $1\sim l$ 的即是该询问的答案。
#### code
```cpp
struct node
{
	int z,ls,rs;
}t[N<<4];

int n,m,idx;
int a[N], rt[N], lst[N];

void insert(int k,int &p,int lp,int be=0,int ed=n)// lst可能 = 0，所以要从 0 开始
{
	p = ++ idx;
	t[p] = t[lp];
	t[p].z ++;
	if(be == ed)	return;
	int mid = (be + ed) >> 1;
	if(k <= mid)	insert(k,t[p].ls,t[lp].ls,be,mid);
	else	insert(k,t[p].rs,t[lp].rs,mid+1,ed);
}

int query(int k,int lp,int rp,int be=0,int ed=n)
{
	if(ed <= k)	return t[rp].z - t[lp].z;
	int mid = (be + ed) >> 1;
	int res = query(k,t[lp].ls,t[rp].ls,be,mid);
	if(mid+1 <= k)	res += query(k,t[lp].rs,t[rp].rs,mid+1,ed);
	return res;
}

void func(void)
{
	cin >> n;
	for(int i=1;i<=n;++i)	cin >> a[i];
	for(int i=1;i<=n;++i)
	{
		insert(lst[a[i]],rt[i],rt[i-1]);
		lst[a[i]] = i;
	}
	cin >> m;
	for(int i=1;i<=m;++i)
	{
		int l,r;	cin >> l >> r;
		cout << query(l-1,rt[l-1],rt[r]) << '\n';
	}
}
```
## 树状数组
### 模板
#### 单点修改
```cpp
int n;
int a[N], t[N];
int lowbit(int z)
{
    return z&-z;
}
void put(int p,int z)// 单点修改
{
    for(int i=p;i<=n;i+=lowbit(i))  t[i] += z;
}
int query(int l,int r)// 区间查询
{
    int res;
    for(int i=l-1;i>=1;i-=lowbit(i))	res -= t[i];
	for(int i=r;i>=1;i-=lowbit(i))		res += t[i];
    return res2-res1;
}
```
#### 区间修改
维护差分
$\sum_{i=1}^n a_i = \sum_{i=1}^n \overbrace{(n+1)d_i}^{t_1} - \sum_{i=1}^n\overbrace{id_i}^{t_2}$

```cpp
int n;
int t[N],ti[N];

int lowbit(int i)
{
	return i&-i;
}
void put(int l,int r,int z)
{
	for(int i=l;i<=n;i+=lowbit(i))	t[i] += z, ti[i] += l*z;
	for(int i=r+1;i<=n;i+=lowbit(i))	t[i] -= z, ti[i] -= (r+1)*z;
}
int query(int l,int r)
{
	int res = 0;
	for(int i=l-1;i>=1;i-=lowbit(i))	res -= (l)*t[i] - ti[i];
	for(int i=r;i>=1;i-=lowbit(i))		res += (r+1)*t[i] - ti[i];
	return res;
}
```

### 维护逆序对
权值树状数组

按出现顺序依次加入树状数组，每次可得当前小于（大于）等于自己的数目（也就是前面比自己小/大的数目），计算即可得逆序对。
```c++
int n,ans;
vector<int> t(N)
vector<int> dis,;// 离散化

int get(int x)// 寻找离散化下标
{
	return lower_bound(dis.begin(),dis.end(),x)-dis.begin()+1;
	// 下标存入树状数组，保证下标从1开始
}

int lowbit(int z)
{
	return z&-z;
}
void update(int p)
{
	for(int i=p;i<=n;i+=lowbit(i))	t[i] ++;
}
int query(int p)
{
	int res = 0;
	for(int i=p;i>=1;i-=lowbit(i))	res += t[i];
	return res;
}

void func(void)
{
	cin >> n;
	vector<int> a(n);
	for(int i=0;i<n;++i)	cin >> a[i];
	dis = a;
	sort(dis.begin(),dis.end());
	dis.erase(unique(dis.begin(),dis.end()),dis.end());
	for(int i=0;i<n;++i)
	{
		ans += i-query(get(a[i]));
		update(get(a[i]));
	}
	cout << ans << '\n';
}
```

### 题目
#### 维护区间数的种类

让数在一个区间只记录一次，但具体操作略有不同。

权值树状数组维护各个数出现的位置，离线处理询问。

将询问按 $a.r < b.r$ 排序，保证每次询问只会新增一个点。

对于新增的点 $a_i$
- 如果之前未曾出现，则 $t_i + 1$，并记录该数出现位置。
- 如果已经出现过，则把原位置 $t_{last-i - 1}$，新位置 $t_i+1$ ，并更新出现的位置。

对于一个询问
- 右端点可能 $+x$，也可能不变化，每次需要将新增的**所有点**更新。
- 因为每次询问的右端点都是 $i$，所以不会出现少记录。
- 最后直接查询 $[t_l,t_r]$ 的总和即可。

```cpp
int n,m;
int p[N];
int a[N],t[N];

struct node
{
	int l,r,id;
	bool operator < (const node &i)	const
	{
		return (r == i.r ? l < i.l : r < i.r);// l 无所谓，保证 r 升序即可
	}
};

int lowbit(int x)
{
    return x&-x;
}

void update(int p,int z)
{
    for(int i=p;i<=n;i+=lowbit(i))    t[i] += z;
}

int query(int l,int r)
{
    int res = 0;
    for(int i=l-1;i>=1;i-=lowbit(i))  res -= t[i];
    for(int i=r;i>=1;i-=lowbit(i))    res += t[i];
    return res;
}

void func(void)
{
	cin >> n;
	for(int i=1;i<=n;++i)	cin >> a[i];
	cin >> m;
	vector<node> q(m+1);
	vector<int> ans(m+1);
	for(int i=1;i<=m;++i)
	{
		cin >> q[i].l >> q[i].r;
		q[i].id = i;
	}
	sort(q.begin()+1,q.end());
	for(int i=1;i<=m;++i)
	{
		for(int j=q[i-1].r+1;j<=q[i].r;++j)
		{
			int t = a[j];
			if(p[t])	update(p[t],-1);
			p[t] = j;
			update(p[t],1);
		}
		ans[q[i].id] = query(q[i].l,q[i].r);
	}
	for(int i=1;i<=m;++i)	cout << ans[i] << '\n';
}
```

**若是查询出现两次或者 $k$ 次出现的数，只需要存储前 $k$ 个数的位置，然后相同做法**
```cpp
struct TIII
{
	int l,r,id;
	bool operator < (const TIII &i)	const
	{
		return (r == i.r ? l < i.l : r < i.r);
	}
}q[N];

int n,c,m;
// lst - 上一次出现位置，l2t - 上上次出现位置
int a[N],t[N],lst[N],l2t[N],ans[N];

int lowbit(int i)
{
	return i&-i;
}

void modify(int p,int z)
{
	for(int i=p;i<=n;i+=lowbit(i))	t[i] += z;
}

int query(int l,int r)
{
	int res = 0;
	for(int i=l-1;i>=1;i-=lowbit(i))	res -= t[i];
	for(int i=r;i>=1;i-=lowbit(i))	res += t[i];
	return res;
}

void func(void)
{
	cin >> n >> c >> m;
	for(int i=1;i<=n;++i)	cin >> a[i];
	for(int i=1;i<=m;++i)
	{
		cin >> q[i].l >> q[i].r;
		q[i].id = i;
	}
	sort(q+1,q+m+1);
	for(int i=1;i<=m;++i)
	{
		for(int j=q[i-1].r+1;j<=q[i].r;++j)
		{
			if(l2t[a[j]])	modify(l2t[a[j]],-1);
			if(lst[a[j]])	modify(lst[a[j]],1);
			l2t[a[j]] = lst[a[j]];
			lst[a[j]] = j;
		}
		ans[q[i].id] = query(q[i].l,q[i].r);
		
	}
	for(int i=1;i<=m;++i)	cout << ans[i] << '\n';
}
```
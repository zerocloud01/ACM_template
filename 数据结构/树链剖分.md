## 树链剖分
### 轻重链剖分
**处理：**
求重链 $O(n)$：
- 将子树中总结点最多的视为重儿子，因为轻链的大小 $\le sum/2$，所以每次走轻儿子等同于抛弃 $sum/2$ 的点，那么可以保证最终复杂度 $\le n\log n$

链分解 $O(n)$：
- 重儿子继承父节点值，而轻儿子以本身为链头作为重链继续剖分。最终得到若干重链。	

**操作：**
链操作 $O$ ($\log n \times$ 区间修改)：
- dfs序保证每个子树在 `dfn` 上连续，而重链剖分保证每条重链上的点在 `dfn` 上连续。这样就可以对链区间修改
- 将重链缩为一点后，树的深度 $\le \log n$，那么可以用类似暴力的 $lca$ 求两个重链树的父链，每次会操作所在重链头到该节点的数据。最终两点走到同一链，在操作两点见的数据即可。

子树操作 $O$(区间修改)
- 利用 `dfn`，子树管辖区间是 $[dfn_x,dfn_x+size_x-1]$

```cpp
int idx;// dfs序辅助变量
vector<int> v[N]; 
int a[N],ta[N];// 节点值 映射dfn值
int hson[N],top[N],sz[N];// 重儿子 链头 子树大小
int fa[N],dfn[N],dep[N];// 父节点 dfs序 深度

void dfs_size(int p,int lp)// 求重链
{
	fa[p] = lp;
	dep[p] = dep[lp] + 1;
	sz[p] = 1;
	hson[p] = 0;
	for(auto &i : v[p])
	{
		if(i == lp)	continue;
		dfs_size(i,p);
		sz[p] += sz[i];
		if(sz[hson[p]] < sz[i])	hson[p] = i;
	}
}

void dfs_chain(int p,int tp)// 链分解
{
	top[p] = tp;
	dfn[p] = ++ idx;
	ta[idx] = a[p];
	if(!hson[p])	return;
	dfs_chain(hson[p],tp);
	for(auto &i : v[p])
	{
		if(i != fa[p] && i != hson[p])	dfs_chain(i,i);
	}
}

void put_path(int x,int y)// 操作 x - y 链
{
    while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		/*
        put(dfn[top[x]],dfn[x]);
        */
		x = fa[top[x]];
	}
	if(dep[x] > dep[y])	swap(x,y);
	// put(dfn[x],dfn[y],z);
}

void put_tree(int x)// 操作 x 的所有子树
{
	put(dfn[x],dfn[x]+sz[x]-1);
}
```

### dsu on tree
利用重链剖分处理离线**子树信息查询**问题
> 类似莫队

处理无法轻松合并的信息
> 线段树做不到或者很麻烦的，比如区间内数的种类

因为不同子树的 `dfn` 只存在包含或者相离，那么父节点是可以利用一个子节点的信息或者说信息数组使用，也就是继承其信息。
> 因为信息比较复杂，无法简单合并，那么多个点的信息只能用一个了。

根据重链剖分的分析，我们必然是使用重儿子的信息，而轻儿子的信息必须清除重新统计。

本质是逆序的重链剖分。
```cpp
int n,idx,
vector<int> v[N];
int ans[N];// 子树答案
int fa[N],sz[N],dfn[N],id[N],hson[N];
int res;// 当前子树答案
// int tmp[N]; 辅助数组

void dfs(int p,int lp)// 求重儿子
{
	fa[p] = lp;
	sz[p] = 1;
	hson[p] = 0;
	// 因为不需要链信息，所以在第一次就可以直接求dfn
	dfn[p] = ++ idx;
	id[idx] = p;
	for(auto &i : v[p])
	{
		if(i == lp)	continue;
		dfs(i,p);
		sz[p] += sz[i];
		if(sz[hson[p]] < sz[i])	hson[p] = i;
	}
}

void put(int p)// 操作
{
    for(int i=dfn[p];i<dfn[p]+sz[p];++i)
    {
        if(id[i] == hson[p])
        {
            i = dfn[hson[p]]+sz[hson[p]]-1;
            // 这里如果直接等于 dfn[hson[p]]+sz[hson[p]]，可能恰好超过 dfn[p]，
            // 加上特判的码量差不多，就没必要了。
            continue;
        }
        // 辅助数组操作
        tmp[id[i]] ++;
        res ++;
    }
    return res;
}

void init(int p)// 清空
{
    for(int i=dfn[p];i<dfn[p]+sz[p];++i)    tmp[id[i]] --;
}

void dsu(int p,bool del)// 求子树信息
{
	for(auto &i : v[p])
	{
		if(i != fa[p] && i != hson[p])	dsu(i,true);
	}
	if(hson[p])	dsu(hson[p],false);
    put(p);
	ans[p] = res;
	if(del)
	{
		init(p);
	}
}
```
## Manacher
### 概念
对于字符串 $s$，$s = s_1,s_2,\ldots,s_n$
**反转串** $s' = s_n,s_{n-1},\ldots,s_1$
**回文串**：$s = s'$

> $(())$ 不是回文串，$())($ 是

**回文中心：**
奇回文串，$s_{\frac{n+1}{2}}, ab$ **$c$** $ba$
偶回文串，$s_{\frac{n}{2}}$ 与 $s_{\frac{n+1}{2}}$ 之间, $abc$ **$|$** $cba$

**回文半径：**
回文中心到左右端点的距离，$abcba$ 和 $abccba$ 的回文回文半径都是 $3$

**回文串表示：**
用一个二元组 `<回文中心,回文半径>` 表示回文串。

#### 回文串性质
**长度与半径**
奇串：$L = 2R-1$
偶串：$L = 2R$

**二分性**
半径 $-1$ 等价于删除两端字符，任然是一个回文串。

**回文串和border**
回文串的回文前后缀**等价于border**
**为充要条件**
> abaaba，回文前后缀 $aba,a$
#### 前期处理
为了奇偶串的处理统一，我们给每个字符的中间以及首位插入 $\#$，或者其他字符集不会出现的字符。

奇串：$aba \rightarrow \#a\#b\#a\#$，回文中心 $b$，长度为 $7$
奇串：$abba \rightarrow \#a\#b\#b\#a\#$，回文中心 $\#$，长度为 $9$

$|S^{\#}| = 2 |S| + 1$
$|S| = |S^{\#}| / 2$

那么所有极长回文串都是奇数串，首位为 $\#$

#### 算法流程
**定义 $Len_i$** 表示 $i$ 的最大回文半径
然后定义**最右回文串 $P$ 为右端点最大的回文串中心

**对于 $i > R_P$**
暴力左右拓展，求回文半径。
同时更新最右回文串

**对于 $i \le R_P$**
根据对称性，因为 $i$ 被 $S_P$ 包括，那么可以直接以使用 $P$ 对称位置的回文串
- 若是对称位置的左端点不超过 $L_P$，则 $Len_i$ 对称位置半径
- 若是超过，则继承不超过的部分，然后继续往两侧暴力拓展。

**复杂度分析：**
暴力拓展貌似复杂度很高，但是每次暴力拓展必然伴随着 $R ++$，且每个点只会被向右拓展访问一次。所以实际复杂度为 **$O(n)$**

**本质不同回文串**
不同的回文串。
对于Manacher，新回文串一定出现在 $R$ 右移时，因此本质不同回文串最多 $n$，个
但是右移出现这个条件充分不必要，所以还需要 $Hash$ 去重

$Manacher$ 本身是个简单算法，但是要注意奇偶串的匹配
### 模板
为了处理奇偶串，我们给串之间与首位添加 $\#$，或者其他不出现在字符集的字符。

$R_i$ 表示以 $i$ 为回文中心的回文串的回文半径
```cpp
int L[N];

void manacher(string &s)
{
	string st = "_#";
	for(auto &i : s)	st += i, st += '#';
	int p = 0;
	L[0] = 1;
	for(int i=1;i<st.size();++i)
	{
		int r = p+L[p]-1;
		if(i <= r)	L[i] = min(L[2*p-i],r-i+1);
		else	L[i] = 1;
		while(st[i-L[i]] == st[i+L[i]])	L[i] ++;
		if(i+L[i]-1 > r)	p = i;
	}
}
```
实际回文串长度 $= L_i - 1$

### 题目
#### 非典型回文
[P3501 [POI 2010] ANT-Antisymmetry](https://www.luogu.com.cn/problem/P3501)
与自己的反串进行匹配，并且这题只有偶串可以用，需要跳过奇数串。
```cpp
void func(void)
{
	int n;	cin >> n;
	string s0;	cin >> s0;
	vector<int> a(2);
	a[0] = -100, a[1] = 2;
	for(auto &i : s0)
	{
		a.push_back((int)(i-'0'));
		a.push_back(2);
	}
	a.push_back(-200);
	vector<int> L(a.size());
	L[0] = 1;	int p = 0;
	for(int i=1;i<a.size();++i)
	{
		int r = p+L[p]-1;
		if(i <= r)	L[i] = min(L[2*p-i],r-i+1);
		else	L[i] = 1;
		while(a[i-L[i]] + a[i+L[i]] == 4 || a[i-L[i]] + a[i+L[i]] == 1)	L[i] ++;
		if(i+L[i]-1 > r)	p = i;
	}
	int ans = 0;
	for(int i=1;i<a.size();i+=2)	ans += L[i]/2;
	cout << ans << '\n';
}
```
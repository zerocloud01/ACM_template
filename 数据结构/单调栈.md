## 单调栈
用 `vector` 而非 `stack`，这样可以访问栈内元素。
> 单要论速度还得是数组
### 模板
```cpp
vector<int> stp;
vector<int> stk;
for(int i=1;i<=n;++i)
{
	while(stk.size() && check(a[i]))	stk.pop_back();
	stp.push_back(st.size() ? st.back() : -1);
	st.push(a[i]);
}
```
#### 左侧第一个比自己大的元素
```cpp
vector<int> ans;
vector<int> stk;
for(int i=n;i>=1;--i)
{
	while(stk.size() && a[stk.back()] <= a[i])	stk.pop_back();
	ans[i] = (stk.size() ? stk.back() : 0);
	stk.push_back(i);
}
```

### 应用
#### 二分单调栈
[P6510 奶牛排队](https://www.luogu.com.cn/problem/P6510)
找出一个连续子串，要求最左边的元素 $A$ 是最矮小，最右边的 $B$ 是最大的，且 $B$ 大于 $A$。中间如果存在元素，则大小不能和 $A,B$ 相同。问这样的子串最长是多少？

```cpp
void func(void)
{
	int n;	cin >> n;
	vector<int> a(n+1),stk1, stk2;
	for(int i=1;i<=n;++i)	cin >> a[i];
	int ans = 0;
	for(int i=1;i<=n;++i)
	{
		while(stk1.size() && a[stk1.back()] >= a[i])	stk1.pop_back();
		while(stk2.size() && a[stk2.back()] < a[i])	stk2.pop_back();
		if(stk1.size())
		{
			if(!stk2.size())	ans = max(ans,i-stk1[0]+1);
			else
			{
				auto it = lower_bound(stk1.begin(),stk1.end(),stk2.back());
				if(it != stk1.end())	ans = max(ans,i-*it+1);
			}
		}
		stk1.push_back(i), stk2.push_back(i);
	}
	cout << ans << '\n';
}
```
[TOC]
## 高精度
### 加法
### 减法
### 乘法
#### 朴素
#### FFT
**需要给被乘的两个数设置为复数**
```cpp
struct cpx
{
	double x,y;
	cpx operator + (const cpx i)	{return {x+i.x,y+i.y};}
	cpx operator - (const cpx i)	{return {x-i.x,y-i.y};}
	cpx operator * (const cpx i)	{return {x*i.x-y*i.y,x*i.y+y*i.x};}
};

vector<cpx> a,b;

void fft(vector<cpx> &a,int L,int op)
{
	// 反转变换
	vector<int> r(L);
	for(int i=0;i<L;++i)	r[i] = r[i>>1]/2 + (i&1 ? L>>1 : 0);
	for(int i=0;i<L;++i)
	{
		if(i < r[i])	swap(a[i],a[r[i]]);
	}
	for(int i=2;i<=L;i<<=1)
	{
		cpx wk = {cos(2*pi/i),sin(2*pi/i)*op};
		for(int j=0;j<L;j+=i)
		{
			cpx w = {1,0};
			for(int k=j;k<(j+(i>>1));++k,w=w*wk)
			{
				cpx x = a[k], y = a[k+(i>>1)]*w;
				a[k] = x+y, a[k+(i>>1)] = x-y;
			}
		}
	}
	if(op == -1)
	{
		for(int i=0;i<L;++i)	a[i].x /= L, a[i].y /= L;
	}
}

vector<int> mul(vector<cpx> &a,vector<cpx> &b)
{
	vector<int> res;
	int n = a.size()+b.size(), L = 1;
	while(n >= L)	L <<= 1;
	a.resize(L), b.resize(L);
	fft(a,L,1), fft(b,L,1);
	for(int i=0;i<L;++i)	a[i] = a[i]*b[i];
	fft(a,L,-1);
	int t = 0;
	for(int i=0;i<n-1||t;++i)
	{
		t += (a[i].x+0.5);
		res.push_back(t%10);
		t /= 10;
	}
	return res;
}
```
#### NTT
```cpp
const int P = 998244353;
const int G = 3;
const int inv_G = 332748118;// inv(g)

int qpow(int a,int b)
{
	int z = 1;
	a %= P;
	while(b)
	{
		if(b&1)	z = (z*a)%P;
		a = (a*a)%P;
		b >>= 1;
	}
	return z;
}

void ntt(vector<int> &a,int L,int op)
{
	vector<int> r(L);
	for(int i=0;i<L;++i)	r[i] =  r[(i>>1)]/2+(i&1 ? L>>1 : 0);
	for(int i=0;i<L;++i)
	{
		if(i < r[i])	swap(a[i],a[r[i]]);
	}
	for(int i=2;i<=L;i<<=1)
	{
		int gk = qpow(op==1 ? G : inv_G,(P-1)/i);
		for(int j=0;j<L;j+=i)
		{
			int g = 1;
			for(int k=j;k<j+(i>>1);++k,g=g*gk%P)
			{
				int x = a[k], y = a[k+(i>>1)]*g%P;
				a[k] = (x+y)%P, a[k+(i>>1)] = (x-y+P)%P;
			}
		}
	}
	if(op == -1)
	{
		int inv_L = qpow(L,P-2);
		for(int i=0;i<L;++i)	a[i] = a[i]*inv_L%P;
	}
}

vector<int> mul(vector<int> &a,vector<int> &b)
{
	vector<int> res;
	int n = a.size()+b.size(), L = 1;
	while(n >= L)	L <<= 1;
	a.resize(L), b.resize(L);
	ntt(a,L,1), ntt(b,L,1);
	for(int i=0;i<L;++i)	a[i] = a[i]*b[i]%P;
	ntt(a,L,-1);
	int t = 0;
	for(int i=0;i<n-1||t;++i)
	{
		t += a[i];
		res.push_back(t%10);
		t /= 10;
	}
	return res;
}
```